# -*- coding: utf-8 -*-
"""Untitled41.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N3ZbdQgOqvmQ992rhKQ75TY1k8saC0sZ
"""

import streamlit as st
import openpyxl
from openpyxl.styles import PatternFill
from openpyxl import load_workbook
import io
from datetime import datetime
import re

# Set page configuration.
st.set_page_config(page_title="Bank Reconciliation App", layout="wide")

# Global dictionary to hold processed workbooks.
processed_wbs = {}
# Global variables to store full transaction lists for final matching.
full_bank_txns = None
full_book_txns = None

# Define color fills for conditional formatting.
green_fill = PatternFill(start_color="C6EFCE", end_color="C6EFCE", fill_type="solid")  # matched
red_fill = PatternFill(start_color="FFC7CE", end_color="FFC7CE", fill_type="solid")      # unmatched

# ========= Helper Functions =========
def extract_numbers_with_tail(text):
    """
    Extracts numeric tokens from text.
    For each token with >=4 digits, also adds its last 4 digits.
    """
    if text is None:
        return set()
    tokens = re.findall(r'\d+', str(text))
    result = set(tokens)
    for token in tokens:
        if len(token) >= 4:
            result.add(token[-4:])
    return result

def extract_transactions(ws):
    """
    Extracts bank and book transactions from the worksheet.
    Includes row index and ID.
    """
    bank_txns = []
    book_txns = []
    # Data rows start at row 2.
    for row_idx, row in enumerate(ws.iter_rows(min_row=2), start=2):
        # Bank fields (Columns A–E)
        bank_date = row[0].value           # Column A: Bank Date
        bank_id = row[1].value             # Column B: Bank unique ID
        bank_narration = row[2].value        # Column C: Narration
        bank_amount = row[3].value         # Column D: Bank Amount
        bank_dr_cr = row[4].value          # Column E: DR/CR

        # Book fields (Columns F–P)
        book_amount = row[5].value         # Column F: Book Amount
        book_col_g = row[6].value          # Column G
        book_id = row[7].value             # Column H: Book ID (old logic)
        book_date = row[8].value           # Column I: Book Date
        book_col_j = row[9].value          # Column J: New key for unmatched matching
        book_col_k = row[10].value         # Column K
        book_col_l = row[11].value         # Column L
        book_col_m = row[12].value         # Column M
        book_description = row[13].value   # Column N: Book Description (narration)
        book_col_o = row[14].value         # Column O
        book_dr_cr = row[15].value         # Column P

        if bank_amount is not None:
            bank_txns.append({
                'row_idx': row_idx,
                'row': row,
                'date': bank_date,
                'id': bank_id,
                'amount': bank_amount,
                'dr_cr': bank_dr_cr,
                'narration': bank_narration,
                'cell': row[3],  # For coloring bank Amount cell.
                'matched': False,
                'narration_matched': False
            })
        if book_amount is not None:
            book_txns.append({
                'row_idx': row_idx,
                'row': row,
                'date': book_date,
                'id': book_id,
                'col_j_val': book_col_j,
                'amount': book_amount,
                'dr_cr': book_dr_cr,
                'description': book_description,
                'cell': row[5],  # For coloring book Amount cell.
                'matched': False,
                'reversal': False,
                'narration_matched': False
            })
    return bank_txns, book_txns

def create_extra_sheets(wb, bank_txns, book_txns):
    """
    Creates 'Reversals', 'Missing in Book', and 'Extra in Book' sheets.
    """
    ws = wb.active
    # Remove sheets if they already exist.
    for sheet_name in ["Reversals", "Missing in Book", "Extra in Book"]:
        if sheet_name in wb.sheetnames:
            wb.remove(wb[sheet_name])
    # Reversal detection among Book transactions.
    reversal_rows = []
    book_txns_copy = [txn.copy() for txn in book_txns]
    for i in range(len(book_txns_copy)):
        if not book_txns_copy[i]['reversal']:
            for j in range(i + 1, len(book_txns_copy)):
                if not book_txns_copy[j]['reversal']:
                    if book_txns_copy[i]['amount'] == book_txns_copy[j]['amount']:
                        if ((book_txns_copy[i]['dr_cr'] == "DR" and book_txns_copy[j]['dr_cr'] == "CR") or
                            (book_txns_copy[i]['dr_cr'] == "CR" and book_txns_copy[j]['dr_cr'] == "DR")):
                            if (book_txns_copy[i]['date'] is not None and book_txns_copy[j]['date'] is not None):
                                diff_days = abs((book_txns_copy[i]['date'] - book_txns_copy[j]['date']).days)
                                if diff_days <= 10:
                                    book_txns_copy[i]['reversal'] = True
                                    book_txns_copy[j]['reversal'] = True
                                    reversal_rows.append(book_txns_copy[i]['row'])
                                    reversal_rows.append(book_txns_copy[j]['row'])
                                    break

    # Create Reversals sheet.
    rev_sheet = wb.create_sheet("Reversals")
    header_values = [cell.value for cell in next(ws.iter_rows(min_row=1, max_row=1))]
    book_header_values = header_values[5:16]
    rev_sheet.append(book_header_values)
    for r in reversal_rows:
        rev_sheet.append([cell.value for cell in r[5:16]])

    # Missing in Book sheet.
    miss_sheet = wb.create_sheet("Missing in Book")
    miss_sheet.append(header_values)
    for txn in bank_txns:
        if not txn['matched']:
            miss_sheet.append([cell.value for cell in txn['row']])

    # Extra in Book sheet.
    extra_sheet = wb.create_sheet("Extra in Book")
    extra_sheet.append(header_values)
    for txn in book_txns:
        if not txn['matched']:
            extra_sheet.append([cell.value for cell in txn['row']])

# ========= Processing Functions =========
def process_amount_only(wb):
    """Stage 2: Matches transactions based on Amount only."""
    ws = wb.active
    bank_txns, book_txns = extract_transactions(ws)
    for btxn in bank_txns:
        for bktxn in book_txns:
            if not btxn['matched'] and not bktxn['matched']:
                if btxn['amount'] == bktxn['amount']:
                    btxn['matched'] = True
                    bktxn['matched'] = True
                    break
    for txn in bank_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    for txn in book_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    create_extra_sheets(wb, bank_txns, book_txns)
    return wb

def process_drcr(wb):
    """Stage 3: Matches transactions based on Amount + DR/CR."""
    ws = wb.active
    bank_txns, book_txns = extract_transactions(ws)
    for btxn in bank_txns:
        for bktxn in book_txns:
            if not btxn['matched'] and not bktxn['matched']:
                if btxn['amount'] == bktxn['amount'] and (
                   (btxn['dr_cr'] == "DR" and bktxn['dr_cr'] == "CR") or
                   (btxn['dr_cr'] == "CR" and bktxn['dr_cr'] == "DR")
                ):
                    btxn['matched'] = True
                    bktxn['matched'] = True
                    break
    for txn in bank_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    for txn in book_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    create_extra_sheets(wb, bank_txns, book_txns)
    return wb

def process_date(wb):
    """Stage 4: Matches transactions based on Amount + DR/CR + Date (within 10 days)."""
    ws = wb.active
    bank_txns, book_txns = extract_transactions(ws)
    for btxn in bank_txns:
        for bktxn in book_txns:
            if not btxn['matched'] and not bktxn['matched']:
                if btxn['amount'] == bktxn['amount'] and (
                    (btxn['dr_cr'] == "DR" and bktxn['dr_cr'] == "CR") or
                    (btxn['dr_cr'] == "CR" and bktxn['dr_cr'] == "DR")
                ):
                    if btxn['date'] is not None and bktxn['date'] is not None:
                        diff_days = abs((btxn['date'] - bktxn['date']).days)
                        if diff_days <= 10:
                            btxn['matched'] = True
                            bktxn['matched'] = True
                            break
                    else:
                        btxn['matched'] = True
                        bktxn['matched'] = True
                        break
    for txn in bank_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    for txn in book_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    create_extra_sheets(wb, bank_txns, book_txns)
    return wb

def process_full(wb):
    """
    Stage 5: Standard matching (Amount + DR/CR + Date) plus narration matching.
    Creates a "Matched Entries" sheet.
    """
    global full_bank_txns, full_book_txns
    ws = wb.active
    bank_txns, book_txns = extract_transactions(ws)
    if "Matched Entries" in wb.sheetnames:
        wb.remove(wb["Matched Entries"])

    standard_matched_pairs = []
    for btxn in bank_txns:
        for bktxn in book_txns:
            if not btxn['matched'] and not bktxn['matched']:
                if btxn['amount'] == bktxn['amount'] and (
                   (btxn['dr_cr'] == "DR" and bktxn['dr_cr'] == "CR") or
                   (btxn['dr_cr'] == "CR" and bktxn['dr_cr'] == "DR")
                ):
                    if btxn['date'] is not None and bktxn['date'] is not None:
                        diff_days = abs((btxn['date'] - bktxn['date']).days)
                        if diff_days <= 10:
                            btxn['matched'] = True
                            bktxn['matched'] = True
                            standard_matched_pairs.append((btxn, bktxn))
                            break
                    else:
                        btxn['matched'] = True
                        bktxn['matched'] = True
                        standard_matched_pairs.append((btxn, bktxn))
                        break
    narration_matched_pairs = []
    for pair in standard_matched_pairs:
        btxn, bktxn = pair
        bank_tokens = extract_numbers_with_tail(btxn.get('narration'))
        book_tokens = extract_numbers_with_tail(bktxn.get('description'))
        if bank_tokens and book_tokens:
            inter = bank_tokens.intersection(book_tokens)
            if inter:
                btxn['narration_matched'] = True
                bktxn['narration_matched'] = True
                narration_matched_pairs.append((btxn, bktxn, inter))
            else:
                btxn['narration_matched'] = False
                bktxn['narration_matched'] = False
        else:
            btxn['narration_matched'] = False
            bktxn['narration_matched'] = False

    for txn in bank_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    for txn in book_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill

    create_extra_sheets(wb, bank_txns, book_txns)

    me_sheet = wb.create_sheet("Matched Entries")
    header = next(ws.iter_rows(min_row=1, max_row=1))
    bank_header = [cell.value for cell in header[0:5]]
    book_header = [cell.value for cell in header[5:16]]
    extra_cols = ["Matched Bank Tokens", "Matched Book Tokens"]
    me_sheet.append(bank_header + book_header + extra_cols)

    for pair in narration_matched_pairs:
        btxn, bktxn, tokens = pair
        bank_data = [cell.value for cell in btxn['row'][0:5]]
        book_data = [cell.value for cell in bktxn['row'][5:16]]
        token_str = ", ".join(sorted(tokens))
        me_sheet.append(bank_data + book_data + [token_str, token_str])

    # Store for later stage.
    full_bank_txns = bank_txns
    full_book_txns = book_txns
    return wb

def process_additional(wb):
    """
    Stage 6: Performs additional matching then lists unmatched transactions.
    If full stage hasn’t been run, this function is not invoked.
    """
    global full_bank_txns, full_book_txns
    if full_bank_txns is None or full_book_txns is None:
        st.error("Error: Full narration matching data is not available.")
        return None
    if "Additional Matching" in wb.sheetnames:
        wb.remove(wb["Additional Matching"])

    ws = wb.active
    remaining_bank = [b for b in full_bank_txns if not b.get('narration_matched')]
    remaining_book = [b for b in full_book_txns if not b.get('narration_matched')]
    additional_matches = []
    used_book_indices = set()
    for btxn in remaining_bank:
        for idx, bktxn in enumerate(remaining_book):
            if idx in used_book_indices:
                continue
            if btxn['amount'] == bktxn['amount'] and (
               (btxn['dr_cr'] == "DR" and bktxn['dr_cr'] == "CR") or
               (btxn['dr_cr'] == "CR" and bktxn['dr_cr'] == "DR")
            ):
                additional_matches.append((btxn, bktxn))
                used_book_indices.add(idx)
                btxn['matched'] = True
                bktxn['matched'] = True
                break

    add_sheet = wb.create_sheet("Additional Matching")
    header = next(ws.iter_rows(min_row=1, max_row=1))
    bank_header = [cell.value for cell in header[0:5]]
    book_header = [cell.value for cell in header[5:16]]
    add_sheet.append(bank_header + book_header + ["Additional Match Status"])

    for pair in additional_matches:
        btxn, bktxn = pair
        bank_data = [cell.value for cell in btxn['row'][0:5]]
        book_data = [cell.value for cell in bktxn['row'][5:16]]
        add_sheet.append(bank_data + book_data + ["Matched"])
        btxn['cell'].fill = green_fill
        bktxn['cell'].fill = green_fill

    matched_entries_bank_ids = set()
    if "Matched Entries" in wb.sheetnames:
        me_sheet = wb["Matched Entries"]
        for row in me_sheet.iter_rows(min_row=2):
            if row[1].value is not None:
                matched_entries_bank_ids.add(row[1].value)
    additional_matched_bank_ids = set()
    for btxn, _ in additional_matches:
        if btxn['id'] is not None:
            additional_matched_bank_ids.add(btxn['id'])
    list1 = matched_entries_bank_ids.union(additional_matched_bank_ids)

    unmatched_bank_rows = set()
    for btxn in full_bank_txns:
        bank_val = btxn['id']
        if bank_val is not None and bank_val not in list1:
            if btxn['row_idx'] not in unmatched_bank_rows:
                bank_data = [cell.value for cell in btxn['row'][0:5]]
                blank_book = ["" for _ in range(11)]
                add_sheet.append(bank_data + blank_book + ["Unmatched Bank"])
                btxn['cell'].fill = red_fill
                unmatched_bank_rows.add(btxn['row_idx'])
        elif bank_val is not None:
            btxn['cell'].fill = green_fill

    matched_entries_book_j = set()
    if "Matched Entries" in wb.sheetnames:
        me_sheet = wb["Matched Entries"]
        for row in me_sheet.iter_rows(min_row=2):
            if len(row) > 9 and row[9].value is not None:
                matched_entries_book_j.add(row[9].value)
    additional_matched_book_j = set()
    for _, bktxn in additional_matches:
        if bktxn['col_j_val'] is not None:
            additional_matched_book_j.add(bktxn['col_j_val'])
    list2 = matched_entries_book_j.union(additional_matched_book_j)

    unmatched_book_rows = set()
    for bktxn in full_book_txns:
        book_val = bktxn['col_j_val']
        if book_val is not None and book_val not in list2:
            if bktxn['row_idx'] not in unmatched_book_rows:
                blank_bank = ["" for _ in range(5)]
                book_data = [cell.value for cell in bktxn['row'][5:16]]
                add_sheet.append(blank_bank + book_data + ["Unmatched Book"])
                bktxn['cell'].fill = red_fill
                unmatched_book_rows.add(bktxn['row_idx'])
        elif book_val is not None:
            bktxn['cell'].fill = green_fill
    return wb

# ========= Streamlit UI =========

st.title("Bank Reconciliation App")

# File uploader.
uploaded_file = st.file_uploader("Upload Excel file", type=["xlsx"])
if uploaded_file is not None:
    st.session_state['file_bytes'] = uploaded_file.getvalue()
    st.success("File uploaded successfully.")

# Sidebar: select operation.
st.sidebar.header("Processing Options")
stage = st.sidebar.selectbox("Choose Processing Stage",
                             options=["Matched Amounts", "DRCR/CRDR", "Date", "Check Narration", "Additional Matching"],
                             index=0)

process_button = st.sidebar.button("Process Stage")

if process_button:
    if 'file_bytes' not in st.session_state:
        st.error("Please upload a file first.")
    else:
        file_bytes = st.session_state['file_bytes']
        wb = load_workbook(io.BytesIO(file_bytes))

        if stage == "Matched Amounts":
            wb = process_amount_only(wb)
            processed_wbs["amount"] = wb
            st.success("Processed: Matched Amounts (Amount Only).")
        elif stage == "DRCR/CRDR":
            wb = process_drcr(wb)
            processed_wbs["drcr"] = wb
            st.success("Processed: DRCR/CRDR (Amount + DR/CR).")
        elif stage == "Date":
            wb = process_date(wb)
            processed_wbs["date"] = wb
            st.success("Processed: Date (Amount + DR/CR + Date).")
        elif stage == "Check Narration":
            wb = process_full(wb)
            processed_wbs["full"] = wb
            st.success("Processed: Check Narration (All Conditions).")
        elif stage == "Additional Matching":
            # If full stage hasn't been run, run it first.
            if "full" not in processed_wbs or processed_wbs["full"] is None:
                st.info("Running 'Check Narration' stage first for Additional Matching...")
                wb = process_full(wb)
                processed_wbs["full"] = wb
            # Then run Additional Matching.
            wb = process_additional(processed_wbs["full"])
            if wb is not None:
                processed_wbs["additional"] = wb
                st.success("Processed: Additional Matching (Final).")

        st.session_state['processed_workbook'] = wb

if 'processed_workbook' in st.session_state:
    output = io.BytesIO()
    key_map = {
        "Matched Amounts": "amount",
        "DRCR/CRDR": "drcr",
        "Date": "date",
        "Check Narration": "full",
        "Additional Matching": "additional"
    }
    key = key_map.get(stage)
    if key in processed_wbs and processed_wbs[key]:
        st.session_state['processed_workbook'].save(output)
        output.seek(0)
        st.sidebar.download_button(label="Download Processed File",
                                   data=output,
                                   file_name=f"Processed_BRS_{key}.xlsx",
                                   mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")