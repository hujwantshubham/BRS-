# -*- coding: utf-8 -*-
"""Untitled41.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N3ZbdQgOqvmQ992rhKQ75TY1k8saC0sZ
"""

import streamlit as st
import openpyxl
from openpyxl.styles import PatternFill
from openpyxl import load_workbook
import io
from datetime import datetime
import re

# Set page config (optional)
st.set_page_config(page_title="Bank Reconciliation App", layout="wide")

# Global variables to hold processed states and transactions.
processed_wbs = {}  # To store the workbook per stage
full_bank_txns = None
full_book_txns = None

# Define color fills for conditional formatting.
green_fill = PatternFill(start_color="C6EFCE", end_color="C6EFCE", fill_type="solid")  # matched
red_fill = PatternFill(start_color="FFC7CE", end_color="FFC7CE", fill_type="solid")      # unmatched

# ========= Helper Functions =========
def extract_numbers_with_tail(text):
    """
    Extracts numeric tokens from text.
    For each token with >=4 digits, also adds its last 4 digits.
    """
    if text is None:
        return set()
    tokens = re.findall(r'\d+', str(text))
    result = set(tokens)
    for token in tokens:
        if len(token) >= 4:
            result.add(token[-4:])
    return result

def extract_transactions(ws):
    """
    Extracts bank and book transactions from the given worksheet.
    Includes row index and 'id' for Column B/H values.
    """
    bank_txns = []
    book_txns = []
    # Data rows start at row 2.
    for row_idx, row in enumerate(ws.iter_rows(min_row=2), start=2):
        # Bank fields (Columns A–E):
        bank_date = row[0].value         # Column A: Bank Date
        bank_id = row[1].value           # Column B: Bank unique ID
        bank_narration = row[2].value      # Column C: Transaction Particulars (narration)
        bank_amount = row[3].value       # Column D: Bank Amount
        bank_dr_cr = row[4].value        # Column E: Bank DR/CR
        # Book fields (Columns F–P):
        book_amount = row[5].value       # Column F: Book Amount
        book_col_g = row[6].value        # Column G
        book_id = row[7].value           # Column H: Book ID (old logic)
        book_date = row[8].value         # Column I: Book Date
        book_col_j = row[9].value        # Column J: New logic – key for unmatched entries
        book_col_k = row[10].value       # Column K
        book_col_l = row[11].value       # Column L
        book_col_m = row[12].value       # Column M
        book_description = row[13].value # Column N: Book Description (narration)
        book_col_o = row[14].value       # Column O
        book_dr_cr = row[15].value       # Column P: Book DR/CR

        if bank_amount is not None:
            bank_txns.append({
                'row_idx': row_idx,       # Unique row identification
                'row': row,               # Original openpyxl row object
                'date': bank_date,
                'id': bank_id,            # Column B value
                'amount': bank_amount,
                'dr_cr': bank_dr_cr,
                'narration': bank_narration,
                'cell': row[3],           # Column D cell for coloring
                'matched': False,
                'narration_matched': False
            })
        if book_amount is not None:
            book_txns.append({
                'row_idx': row_idx,      # Unique row identification
                'row': row,              # Original openpyxl row object
                'date': book_date,
                'id': book_id,           # Column H value (old logic)
                'col_j_val': book_col_j, # Column J value (used for new unmatched logic)
                'amount': book_amount,
                'dr_cr': book_dr_cr,
                'description': book_description,
                'cell': row[5],          # Column F cell for coloring
                'matched': False,
                'reversal': False,
                'narration_matched': False
            })
    return bank_txns, book_txns

def create_extra_sheets(wb, bank_txns, book_txns):
    """
    Creates 'Reversals', 'Missing in Book', and 'Extra in Book' sheets.
    """
    ws = wb.active  # Use the main sheet to copy headers
    # Remove existing extra sheets if they exist to ensure clean runs.
    for sheet_name in ["Reversals", "Missing in Book", "Extra in Book"]:
        if sheet_name in wb.sheetnames:
            wb.remove(wb[sheet_name])

    # Reversal detection among Book transactions.
    reversal_rows = []
    book_txns_copy_for_reversal = [txn.copy() for txn in book_txns]
    for i in range(len(book_txns_copy_for_reversal)):
        if not book_txns_copy_for_reversal[i]['reversal']:
            for j in range(i+1, len(book_txns_copy_for_reversal)):
                if not book_txns_copy_for_reversal[j]['reversal']:
                    if book_txns_copy_for_reversal[i]['amount'] == book_txns_copy_for_reversal[j]['amount']:
                        if ((book_txns_copy_for_reversal[i]['dr_cr'] == "DR" and book_txns_copy_for_reversal[j]['dr_cr'] == "CR") or
                           (book_txns_copy_for_reversal[i]['dr_cr'] == "CR" and book_txns_copy_for_reversal[j]['dr_cr'] == "DR")):
                            if book_txns_copy_for_reversal[i]['date'] is not None and book_txns_copy_for_reversal[j]['date'] is not None:
                                diff_days = abs((book_txns_copy_for_reversal[i]['date'] - book_txns_copy_for_reversal[j]['date']).days)
                                if diff_days <= 10:
                                    book_txns_copy_for_reversal[i]['reversal'] = True
                                    book_txns_copy_for_reversal[j]['reversal'] = True
                                    reversal_rows.append(book_txns_copy_for_reversal[i]['row'])
                                    reversal_rows.append(book_txns_copy_for_reversal[j]['row'])
                                    break
    # Create Reversals sheet.
    rev_sheet = wb.create_sheet("Reversals")
    header_values = [cell.value for cell in next(ws.iter_rows(min_row=1, max_row=1))]
    book_header_values = header_values[5:16]  # Columns F-P for book
    rev_sheet.append(book_header_values)  # Add header to reversal sheet
    for r in reversal_rows:
        rev_sheet.append([cell.value for cell in r[5:16]])

    # Missing in Book sheet.
    miss_sheet = wb.create_sheet("Missing in Book")
    miss_sheet.append(header_values)  # Full header
    for txn in bank_txns:
        if not txn['matched']:
            miss_sheet.append([cell.value for cell in txn['row']])

    # Extra in Book sheet.
    extra_sheet = wb.create_sheet("Extra in Book")
    extra_sheet.append(header_values)  # Full header
    for txn in book_txns:
        if not txn['matched']:
            extra_sheet.append([cell.value for cell in txn['row']])

# ========= Processing Functions =========
def process_amount_only(wb):
    """Stage 2: Matches transactions based on Amount only."""
    ws = wb.active
    bank_txns, book_txns = extract_transactions(ws)
    for btxn in bank_txns:
        for bktxn in book_txns:
            if not btxn['matched'] and not bktxn['matched']:
                if btxn['amount'] == bktxn['amount']:
                    btxn['matched'] = True
                    bktxn['matched'] = True
                    break  # move to next bank txn on match
    for txn in bank_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    for txn in book_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    create_extra_sheets(wb, bank_txns, book_txns)
    return wb

def process_drcr(wb):
    """Stage 3: Matches transactions based on Amount + DR/CR."""
    ws = wb.active
    bank_txns, book_txns = extract_transactions(ws)
    for btxn in bank_txns:
        for bktxn in book_txns:
            if not btxn['matched'] and not bktxn['matched']:
                if btxn['amount'] == bktxn['amount'] and (
                    (btxn['dr_cr'] == "DR" and bktxn['dr_cr'] == "CR") or
                    (btxn['dr_cr'] == "CR" and bktxn['dr_cr'] == "DR")
                ):
                    btxn['matched'] = True
                    bktxn['matched'] = True
                    break
    for txn in bank_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    for txn in book_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    create_extra_sheets(wb, bank_txns, book_txns)
    return wb

def process_date(wb):
    """Stage 4: Matches transactions based on Amount + DR/CR + Date (within 10 days)."""
    ws = wb.active
    bank_txns, book_txns = extract_transactions(ws)
    for btxn in bank_txns:
        for bktxn in book_txns:
            if not btxn['matched'] and not bktxn['matched']:
                if btxn['amount'] == bktxn['amount'] and (
                    (btxn['dr_cr'] == "DR" and bktxn['dr_cr'] == "CR") or
                    (btxn['dr_cr'] == "CR" and bktxn['dr_cr'] == "DR")
                ):
                    if btxn['date'] is not None and bktxn['date'] is not None:
                        diff_days = abs((btxn['date'] - bktxn['date']).days)
                        if diff_days <= 10:
                            btxn['matched'] = True
                            bktxn['matched'] = True
                            break
                    else:
                        # If either date is None, still consider it a match.
                        btxn['matched'] = True
                        bktxn['matched'] = True
                        break
    for txn in bank_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    for txn in book_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    create_extra_sheets(wb, bank_txns, book_txns)
    return wb

def process_full(wb):
    """
    Stage 5: Standard matching (Amount + DR/CR + Date) plus narration matching
    via numeric tokens. Creates "Matched Entries" sheet.
    """
    global full_bank_txns, full_book_txns
    ws = wb.active
    bank_txns, book_txns = extract_transactions(ws)  # Get fresh lists for this stage
    # Remove previous 'Matched Entries' sheet if it exists.
    if "Matched Entries" in wb.sheetnames:
        wb.remove(wb["Matched Entries"])

    # --- Standard Matching (Amount + DR/CR + Date) ---
    standard_matched_pairs = []
    for btxn in bank_txns:
        for bktxn in book_txns:
            if not btxn['matched'] and not bktxn['matched']:
                if btxn['amount'] == bktxn['amount'] and (
                    (btxn['dr_cr'] == "DR" and bktxn['dr_cr'] == "CR") or
                    (btxn['dr_cr'] == "CR" and bktxn['dr_cr'] == "DR")
                ):
                    if btxn['date'] is not None and bktxn['date'] is not None:
                        diff_days = abs((btxn['date'] - bktxn['date']).days)
                        if diff_days <= 10:
                            btxn['matched'] = True
                            bktxn['matched'] = True
                            standard_matched_pairs.append((btxn, bktxn))
                            break
                    else:
                        btxn['matched'] = True
                        bktxn['matched'] = True
                        standard_matched_pairs.append((btxn, bktxn))
                        break
    # --- Narration Matching on Standard Matched Pairs ---
    narration_matched_pairs = []
    for pair in standard_matched_pairs:
        btxn, bktxn = pair
        bank_tokens = extract_numbers_with_tail(btxn.get('narration'))
        book_tokens = extract_numbers_with_tail(bktxn.get('description'))
        if bank_tokens and book_tokens:
            inter = bank_tokens.intersection(book_tokens)
            if inter:
                btxn['narration_matched'] = True
                bktxn['narration_matched'] = True
                narration_matched_pairs.append((btxn, bktxn, inter))
            else:
                btxn['narration_matched'] = False
                bktxn['narration_matched'] = False
        else:
            btxn['narration_matched'] = False
            bktxn['narration_matched'] = False
    # Apply coloring.
    for txn in bank_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    for txn in book_txns:
        txn['cell'].fill = green_fill if txn['matched'] else red_fill
    # Create extra sheets.
    create_extra_sheets(wb, bank_txns, book_txns)
    # Create "Matched Entries" sheet.
    me_sheet = wb.create_sheet("Matched Entries")
    header = next(ws.iter_rows(min_row=1, max_row=1))
    bank_header = [cell.value for cell in header[0:5]]
    book_header = [cell.value for cell in header[5:16]]
    extra_cols = ["Matched Bank Tokens", "Matched Book Tokens"]
    me_sheet.append(bank_header + book_header + extra_cols)
    for pair in narration_matched_pairs:
        btxn, bktxn, tokens = pair
        bank_data = [cell.value for cell in btxn['row'][0:5]]
        book_data = [cell.value for cell in bktxn['row'][5:16]]
        token_str = ", ".join(sorted(tokens))
        me_sheet.append(bank_data + book_data + [token_str, token_str])

    # Store for additional matching.
    full_bank_txns = bank_txns
    full_book_txns = book_txns
    return wb

def process_additional(wb):
    """
    Stage 6: Performs additional matching and then lists all unmatched transactions.
    Unmatched bank transactions are determined by their Column B values not present in the matched sheets.
    Unmatched book transactions are determined by their Column J values.
    """
    global full_bank_txns, full_book_txns
    if full_bank_txns is None or full_book_txns is None:
        st.warning("Please run the 'Check Narration (All Conditions)' stage first.")
        return None
    # Remove "Additional Matching" sheet if exists.
    if "Additional Matching" in wb.sheetnames:
        wb.remove(wb["Additional Matching"])

    ws = wb.active
    # --- Additional Matching Logic (for transactions not narration_matched) ---
    remaining_bank = [b for b in full_bank_txns if not b.get('narration_matched')]
    remaining_book = [b for b in full_book_txns if not b.get('narration_matched')]
    additional_matches = []
    used_book_indices = set()
    for btxn in remaining_bank:
        for idx, bktxn in enumerate(remaining_book):
            if idx in used_book_indices:
                continue
            if btxn['amount'] == bktxn['amount'] and (
                (btxn['dr_cr'] == "DR" and bktxn['dr_cr'] == "CR") or
                (btxn['dr_cr'] == "CR" and bktxn['dr_cr'] == "DR")
            ):
                additional_matches.append((btxn, bktxn))
                used_book_indices.add(idx)
                btxn['matched'] = True
                bktxn['matched'] = True
                break
    # Create "Additional Matching" sheet.
    add_sheet = wb.create_sheet("Additional Matching")
    header = next(ws.iter_rows(min_row=1, max_row=1))
    bank_header = [cell.value for cell in header[0:5]]
    book_header = [cell.value for cell in header[5:16]]
    add_sheet.append(bank_header + book_header + ["Additional Match Status"])

    for pair in additional_matches:
        btxn, bktxn = pair
        bank_data = [cell.value for cell in btxn['row'][0:5]]
        book_data = [cell.value for cell in bktxn['row'][5:16]]
        add_sheet.append(bank_data + book_data + ["Matched"])
        btxn['cell'].fill = green_fill
        bktxn['cell'].fill = green_fill

    # Identify unmatched bank transactions based on Column B.
    matched_entries_bank_col_b_values = set()
    if "Matched Entries" in wb.sheetnames:
        me_sheet = wb["Matched Entries"]
        for row in me_sheet.iter_rows(min_row=2):
            if row[1].value is not None:  # Bank Column B (index 1)
                matched_entries_bank_col_b_values.add(row[1].value)
    additional_matched_bank_col_b_values = set()
    for btxn, _ in additional_matches:
        if btxn['id'] is not None:
            additional_matched_bank_col_b_values.add(btxn['id'])
    list1_matched_bank_col_b = matched_entries_bank_col_b_values.union(additional_matched_bank_col_b_values)
    unmatched_bank_rows_added_to_sheet = set()
    for btxn in full_bank_txns:
        bank_col_b_value = btxn['id']
        if bank_col_b_value is not None and bank_col_b_value not in list1_matched_bank_col_b:
            if btxn['row_idx'] not in unmatched_bank_rows_added_to_sheet:
                bank_data = [cell.value for cell in btxn['row'][0:5]]
                blank_book = ["" for _ in range(11)]
                add_sheet.append(bank_data + blank_book + ["Unmatched Bank"])
                btxn['cell'].fill = red_fill
                unmatched_bank_rows_added_to_sheet.add(btxn['row_idx'])
        elif bank_col_b_value is not None:
            btxn['cell'].fill = green_fill

    # Identify unmatched book transactions based on Column J.
    matched_entries_book_col_j_values = set()
    if "Matched Entries" in wb.sheetnames:
        me_sheet = wb["Matched Entries"]
        for row in me_sheet.iter_rows(min_row=2):
            if len(row) > 9 and row[9].value is not None:
                matched_entries_book_col_j_values.add(row[9].value)
    additional_matched_book_col_j_values = set()
    for _, bktxn in additional_matches:
        if bktxn['col_j_val'] is not None:
            additional_matched_book_col_j_values.add(bktxn['col_j_val'])
    list2_matched_book_col_j = matched_entries_book_col_j_values.union(additional_matched_book_col_j_values)
    unmatched_book_rows_added_to_sheet = set()
    for bktxn in full_book_txns:
        book_col_j_value = bktxn['col_j_val']
        if book_col_j_value is not None and book_col_j_value not in list2_matched_book_col_j:
            if bktxn['row_idx'] not in unmatched_book_rows_added_to_sheet:
                blank_bank = ["" for _ in range(5)]
                book_data = [cell.value for cell in bktxn['row'][5:16]]
                add_sheet.append(blank_bank + book_data + ["Unmatched Book"])
                bktxn['cell'].fill = red_fill
                unmatched_book_rows_added_to_sheet.add(bktxn['row_idx'])
        elif book_col_j_value is not None:
            bktxn['cell'].fill = green_fill
    return wb

# ========= Streamlit UI =========

st.title("Bank Reconciliation App")

# File uploader
uploaded_file = st.file_uploader("Upload Excel file", type=["xlsx"])
if uploaded_file is not None:
    # Store file bytes in session state for reuse
    st.session_state['file_bytes'] = uploaded_file.getvalue()
    st.success("File uploaded successfully.")

# Sidebar for selecting processing stage.
st.sidebar.header("Processing Options")
stage = st.sidebar.selectbox("Choose Processing Stage",
                             options=["Matched Amounts", "DRCR/CRDR", "Date", "Check Narration", "Additional Matching"],
                             index=0)

process_button = st.sidebar.button("Process Stage")
download_button_placeholder = st.sidebar.empty()  # Placeholder for download button later

# Process the file only if uploaded and process_button is clicked.
if process_button:
    if 'file_bytes' not in st.session_state:
        st.error("Please upload a file first.")
    else:
        file_bytes = st.session_state['file_bytes']
        # Load workbook from bytes.
        wb = load_workbook(io.BytesIO(file_bytes))

        # Call the appropriate processing function.
        if stage == "Matched Amounts":
            wb = process_amount_only(wb)
            processed_wbs["amount"] = wb
            st.success("Processed: Matched Amounts (Amount Only).")
        elif stage == "DRCR/CRDR":
            wb = process_drcr(wb)
            processed_wbs["drcr"] = wb
            st.success("Processed: DRCR/CRDR (Amount + DR/CR).")
        elif stage == "Date":
            wb = process_date(wb)
            processed_wbs["date"] = wb
            st.success("Processed: Date (Amount + DR/CR + Date).")
        elif stage == "Check Narration":
            wb = process_full(wb)
            processed_wbs["full"] = wb
            st.success("Processed: Check Narration (All Conditions).")
        elif stage == "Additional Matching":
            if "full" not in processed_wbs or processed_wbs["full"] is None:
                st.error("Please run the 'Check Narration' stage first.")
            else:
                wb = process_additional(processed_wbs["full"])
                processed_wbs["additional"] = wb
                st.success("Processed: Additional Matching (Final).")

        # Save the processed workbook in session state for download.
        st.session_state['processed_workbook'] = wb

# Provide a download button if a processed workbook exists.
if 'processed_workbook' in st.session_state:
    # Save workbook to a BytesIO object.
    output = io.BytesIO()
    # Use the key corresponding to the selected stage.
    key_map = {
        "Matched Amounts": "amount",
        "DRCR/CRDR": "drcr",
        "Date": "date",
        "Check Narration": "full",
        "Additional Matching": "additional"
    }
    key = key_map.get(stage)
    if key in processed_wbs and processed_wbs[key]:
        st.session_state['processed_workbook'].save(output)
        output.seek(0)
        st.sidebar.download_button(label="Download Processed File",
                                   data=output,
                                   file_name=f"Processed_BRS_{key}.xlsx",
                                   mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")